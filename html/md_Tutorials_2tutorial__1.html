<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>sdns: Tutorial 1: Making a naive dig command line tool using sdns library</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="customDoxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">sdns
   </div>
   <div id="projectbrief">low-level DNS library</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

</div><!-- top -->
<div><div class="header">
  <div class="headertitle"><div class="title">Tutorial 1: Making a naive dig command line tool using sdns library</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="anchor" id="autotoc_md1"></a> In this tutorial, we are going to use sdns library to make a naive version of dig command-line utility. <b>dig</b> (Domain Information Groper) is a powerful tool to query domains and get information about different aspects of the domain name system. It supports hundreds of options which can be combined to create a complicated query and several options to display the output result. <em>dig</em> is part of BIND since version 4 (1990) and it's been under development for more than 30 years!</p>
<p>I gave this introduction to say that what we are trying to write here is not even close to <em>dig</em>. The tutorial is just to show how to use sdns library.</p>
<p>Let's create a simple, naive version of the <em>dig</em> to perform simple queries. Our <em>naivedig</em> is capable of querying <em>A</em>, <em>NS</em>, <em>TXT</em>, <em>SOA</em> and <em>MX</em> record for a given domain name. It sends the query to Cloudflare 1.1.1.1 and prints the results. The initial connection is UDP. However, if the packet is truncated, it will switch to TCP and perform the query again (this is the standard behavior of a DNS stub resolver).</p>
<p>Let's start by writing the socket part of the code!</p>
<div class="fragment"><div class="line"><span class="comment">// the following function sends data to UDP socket and receive the result</span></div>
<div class="line"><span class="comment">// the return value of the function is 0 on success and other values on failure.</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> perform_lookup_udp(<span class="keywordtype">char</span> * tosend_buffer, <span class="keywordtype">size_t</span> tosend_len, <span class="keywordtype">char</span> ** toreceive_buffer, <span class="keywordtype">size_t</span> * toreceive_len){</div>
<div class="line">    <span class="keywordtype">char</span> buffer[256] = {0x00};</div>
<div class="line">    <span class="keywordtype">char</span> resolver[] = <span class="stringliteral">&quot;1.1.1.1&quot;</span>;</div>
<div class="line">    <span class="keywordtype">char</span> * error = buffer;</div>
<div class="line">    <span class="keyword">struct </span>timeval tv = {.tv_sec = 3, .tv_usec = 0};</div>
<div class="line">    <span class="keyword">struct </span>sockaddr_in server;</div>
<div class="line">    <span class="keyword">struct </span>sockaddr_in from;</div>
<div class="line">    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> from_size;</div>
<div class="line">    server.sin_port = htons(53);</div>
<div class="line">    server.sin_family = AF_INET;</div>
<div class="line">    server.sin_addr.s_addr = inet_addr(resolver);</div>
<div class="line">    <span class="keywordtype">int</span> sockfd = socket(AF_INET, SOCK_DGRAM, 0);</div>
<div class="line">    <span class="keywordflow">if</span> (sockfd == -1){</div>
<div class="line">        close(sockfd);</div>
<div class="line">        perror(<span class="stringliteral">&quot;Error in creating socket&quot;</span>);</div>
<div class="line">        <span class="keywordflow">return</span> 1;</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">if</span> (setsockopt(sockfd, SOL_SOCKET, SO_RCVTIMEO, &amp;tv, <span class="keyword">sizeof</span>(tv)) != 0){</div>
<div class="line">        perror(<span class="stringliteral">&quot;Error in setsocketopt&quot;</span>);</div>
<div class="line">        close(sockfd);</div>
<div class="line">        <span class="keywordflow">return</span> 2;</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">if</span> (setsockopt(sockfd, SOL_SOCKET, SO_SNDTIMEO, &amp;tv, <span class="keyword">sizeof</span>(tv)) != 0){</div>
<div class="line">        perror(<span class="stringliteral">&quot;Error in setsockeopt() function&quot;</span>);</div>
<div class="line">        <span class="keywordflow">return</span> 3;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    ssize_t sent = 0;</div>
<div class="line">    sent = sendto(sockfd, tosend_buffer, tosend_len, 0, (<span class="keyword">struct</span> sockaddr *)&amp;server, <span class="keyword">sizeof</span>(server));</div>
<div class="line">    <span class="keywordflow">if</span> (sent == -1){  <span class="comment">//error</span></div>
<div class="line">        perror(<span class="stringliteral">&quot;Error in sendto()&quot;</span>);</div>
<div class="line">        close(sockfd);</div>
<div class="line">        <span class="keywordflow">return</span> 4;</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">if</span> (sent == 0){</div>
<div class="line">        fprintf(stderr, <span class="stringliteral">&quot;Can not send the data to the server\n&quot;</span>);</div>
<div class="line">        close(sockfd);</div>
<div class="line">        <span class="keywordflow">return</span> 5;</div>
<div class="line">    }</div>
<div class="line">    <span class="comment">// now let&#39;s receive the data</span></div>
<div class="line">    ssize_t received = 0;</div>
<div class="line">                                                    </div>
<div class="line">    from_size = 0;</div>
<div class="line">    received = recvfrom(sockfd, *toreceive_buffer, 65535, MSG_WAITALL, (<span class="keyword">struct</span> sockaddr*)&amp;server, &amp;from_size);</div>
<div class="line">    <span class="keywordflow">if</span> (received == -1){</div>
<div class="line">        close(sockfd);</div>
<div class="line">        perror(<span class="stringliteral">&quot;Error in receive function&quot;</span>);</div>
<div class="line">        <span class="keywordflow">return</span> 2;</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">if</span> (received == 0){</div>
<div class="line">        close(sockfd);</div>
<div class="line">        <span class="keywordflow">return</span> 2;</div>
<div class="line">    }</div>
<div class="line">    *toreceive_len = received;</div>
<div class="line">    close(sockfd);</div>
<div class="line">    <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
</div><!-- fragment --><p>The <code>perform_lookup_udp()</code> function is just a very simple routine to send data to a destination (1.1.1.1, 53) and receive the response. It has nothing to do with DNS. Whatever data you pass to this function, it will send it to the destination, wait 3 seconds for the response and return the response to the caller. That's it!</p>
<p>The next function is called <code>perform_lookup_tcp()</code>. It's exactly the same as <code>perform_lookup_udp()</code> but instead of UDP, it sends the data using TCP!</p>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> perform_lookup_tcp(<span class="keywordtype">char</span> * tosend_buffer, <span class="keywordtype">size_t</span> tosend_len, <span class="keywordtype">char</span> ** toreceive_buffer, <span class="keywordtype">size_t</span> * toreceive_len){</div>
<div class="line">    <span class="keyword">struct </span>timeval tv = {.tv_sec = 3, .tv_usec = 0};</div>
<div class="line">    <span class="keyword">struct </span>sockaddr_in server;</div>
<div class="line">    <span class="keyword">struct </span>sockaddr_in from;</div>
<div class="line">    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> from_size;</div>
<div class="line">    server.sin_port = htons(53);</div>
<div class="line">    server.sin_family = AF_INET;</div>
<div class="line">    server.sin_addr.s_addr = inet_addr(<span class="stringliteral">&quot;1.1.1.1&quot;</span>);</div>
<div class="line">    <span class="keywordtype">int</span> sockfd = socket(AF_INET, SOCK_STREAM, 0);</div>
<div class="line">    <span class="keywordflow">if</span> (sockfd == -1){</div>
<div class="line">        close(sockfd);</div>
<div class="line">        perror(<span class="stringliteral">&quot;Error in creating socket&quot;</span>);</div>
<div class="line">        <span class="keywordflow">return</span> 1;</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">if</span> (setsockopt(sockfd, SOL_SOCKET, SO_RCVTIMEO, &amp;tv, <span class="keyword">sizeof</span>(tv)) != 0){</div>
<div class="line">        perror(<span class="stringliteral">&quot;Error in setsocketopt&quot;</span>);</div>
<div class="line">        close(sockfd);</div>
<div class="line">        <span class="keywordflow">return</span> 2;</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">if</span> (setsockopt(sockfd, SOL_SOCKET, SO_SNDTIMEO, &amp;tv, <span class="keyword">sizeof</span>(tv)) != 0){</div>
<div class="line">        perror(<span class="stringliteral">&quot;Error in setsockeopt() function&quot;</span>);</div>
<div class="line">        <span class="keywordflow">return</span> 2;</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">if</span> (connect(sockfd, (<span class="keyword">struct</span> sockaddr *) &amp;server, <span class="keyword">sizeof</span>(server)) &lt; 0){</div>
<div class="line">        perror(<span class="stringliteral">&quot;Can not connect to TCP socket&quot;</span>);</div>
<div class="line">        <span class="keywordflow">return</span> 2;</div>
<div class="line">    }</div>
<div class="line">    ssize_t sent = 0;</div>
<div class="line">    uint16_t payload_size = tosend_len;</div>
<div class="line">    <span class="keywordtype">char</span> * payload = (<span class="keywordtype">char</span>*) malloc(2 + payload_size);</div>
<div class="line">    payload[0] = (uint8_t)((payload_size &gt;&gt; 8) &amp; 0xFF);</div>
<div class="line">    payload[1] = (uint8_t)(payload_size &amp; 0xFF);</div>
<div class="line">    memcpy(payload + 2, tosend_buffer, tosend_len);</div>
<div class="line">    sent = send(sockfd, payload, tosend_len + 2, 0);</div>
<div class="line">    <span class="keywordflow">if</span> (sent &lt; 0){</div>
<div class="line">        free(payload);</div>
<div class="line">        perror(<span class="stringliteral">&quot;Cann not send data to TCP socket...&quot;</span>);</div>
<div class="line">        <span class="keywordflow">return</span> 1;</div>
<div class="line">    }</div>
<div class="line">    free(payload);</div>
<div class="line">    ssize_t received = 0;</div>
<div class="line">    <span class="keywordtype">char</span> recv_payload[2] = {0x00};</div>
<div class="line">    received = recv(sockfd, (<span class="keywordtype">void</span>*)recv_payload, 2, 0);</div>
<div class="line">    uint16_t to_allocate = (uint8_t)recv_payload[0] &lt;&lt; 8 |</div>
<div class="line">                           (uint8_t)recv_payload[1];</div>
<div class="line"> </div>
<div class="line">    received = 0;</div>
<div class="line">    <span class="keywordtype">char</span> * receive_payload = (<span class="keywordtype">char</span>*) malloc(to_allocate);</div>
<div class="line">    received = recv(sockfd, receive_payload, to_allocate, MSG_WAITALL);</div>
<div class="line">    <span class="keywordflow">if</span> (received &lt; 0){  <span class="comment">// we have socket error</span></div>
<div class="line">        perror(<span class="stringliteral">&quot;Error reading from socket...&quot;</span>);</div>
<div class="line">        close(sockfd);</div>
<div class="line">        free(receive_payload);</div>
<div class="line">        <span class="keywordflow">return</span> 1;</div>
<div class="line">    }</div>
<div class="line">    *toreceive_len = to_allocate;</div>
<div class="line">    *toreceive_buffer = receive_payload;</div>
<div class="line">    <span class="keywordflow">return</span> 0;   <span class="comment">//success</span></div>
<div class="line">}</div>
</div><!-- fragment --><p>The user input to our <em>naivedig</em> is like './naivedig NS google.com' for example. So we need to write another function to get the second argument and convert the text to an acceptable value for DNS using <a class="el" href="sdns_8h.html#abc5aca5cb71471685dd6f7f66aae28e3">sdns_rr_type</a> enum.</p>
<div class="fragment"><div class="line"><span class="comment">// converts the RR name to its numerical value</span></div>
<div class="line"><span class="keywordtype">int</span> convert_type_to_int(<span class="keywordtype">char</span> * type){</div>
<div class="line">    <span class="comment">// no allocation no leak</span></div>
<div class="line">    <span class="keywordflow">if</span> (type == NULL)</div>
<div class="line">        <span class="keywordflow">return</span> -1;</div>
<div class="line">    <span class="keywordflow">if</span> (strcasecmp(type, <span class="stringliteral">&quot;A&quot;</span>) == 0)</div>
<div class="line">        <span class="keywordflow">return</span> <a class="code hl_enumvalue" href="sdns_8h.html#abc5aca5cb71471685dd6f7f66aae28e3ab7bff52804c24a581f5518e304207ee0">sdns_rr_type_A</a>;</div>
<div class="line">    <span class="keywordflow">if</span> (strcasecmp(type, <span class="stringliteral">&quot;NS&quot;</span>) == 0)</div>
<div class="line">        <span class="keywordflow">return</span> <a class="code hl_enumvalue" href="sdns_8h.html#abc5aca5cb71471685dd6f7f66aae28e3a96447e7daba50e010414291dfb72bc87">sdns_rr_type_NS</a>;</div>
<div class="line">    <span class="keywordflow">if</span> (strcasecmp(type, <span class="stringliteral">&quot;TXT&quot;</span>) == 0)</div>
<div class="line">        <span class="keywordflow">return</span> <a class="code hl_enumvalue" href="sdns_8h.html#abc5aca5cb71471685dd6f7f66aae28e3a24ae80cad9c4bcd631e82967e8604862">sdns_rr_type_TXT</a>;</div>
<div class="line">    <span class="keywordflow">if</span> (strcasecmp(type, <span class="stringliteral">&quot;MX&quot;</span>) == 0)</div>
<div class="line">        <span class="keywordflow">return</span> <a class="code hl_enumvalue" href="sdns_8h.html#abc5aca5cb71471685dd6f7f66aae28e3a529bee829abc98d865757149a4b49318">sdns_rr_type_MX</a>;</div>
<div class="line">    <span class="keywordflow">if</span> (strcasecmp(type, <span class="stringliteral">&quot;SOA&quot;</span>) == 0)</div>
<div class="line">        <span class="keywordflow">return</span> <a class="code hl_enumvalue" href="sdns_8h.html#abc5aca5cb71471685dd6f7f66aae28e3aa54a31e358664cc28897fce304691ed3">sdns_rr_type_SOA</a>;</div>
<div class="line">    <span class="keywordflow">return</span> -2;</div>
<div class="line">}</div>
<div class="ttc" id="asdns_8h_html_abc5aca5cb71471685dd6f7f66aae28e3a24ae80cad9c4bcd631e82967e8604862"><div class="ttname"><a href="sdns_8h.html#abc5aca5cb71471685dd6f7f66aae28e3a24ae80cad9c4bcd631e82967e8604862">sdns_rr_type_TXT</a></div><div class="ttdeci">@ sdns_rr_type_TXT</div><div class="ttdoc">RFC1035 - text strings.</div><div class="ttdef"><b>Definition</b> sdns.h:259</div></div>
<div class="ttc" id="asdns_8h_html_abc5aca5cb71471685dd6f7f66aae28e3a529bee829abc98d865757149a4b49318"><div class="ttname"><a href="sdns_8h.html#abc5aca5cb71471685dd6f7f66aae28e3a529bee829abc98d865757149a4b49318">sdns_rr_type_MX</a></div><div class="ttdeci">@ sdns_rr_type_MX</div><div class="ttdoc">RFC1035 - mail exchange.</div><div class="ttdef"><b>Definition</b> sdns.h:258</div></div>
<div class="ttc" id="asdns_8h_html_abc5aca5cb71471685dd6f7f66aae28e3a96447e7daba50e010414291dfb72bc87"><div class="ttname"><a href="sdns_8h.html#abc5aca5cb71471685dd6f7f66aae28e3a96447e7daba50e010414291dfb72bc87">sdns_rr_type_NS</a></div><div class="ttdeci">@ sdns_rr_type_NS</div><div class="ttdoc">RFC1035 - NS record.</div><div class="ttdef"><b>Definition</b> sdns.h:245</div></div>
<div class="ttc" id="asdns_8h_html_abc5aca5cb71471685dd6f7f66aae28e3aa54a31e358664cc28897fce304691ed3"><div class="ttname"><a href="sdns_8h.html#abc5aca5cb71471685dd6f7f66aae28e3aa54a31e358664cc28897fce304691ed3">sdns_rr_type_SOA</a></div><div class="ttdeci">@ sdns_rr_type_SOA</div><div class="ttdoc">RFC1035 - start of a zone of authority.</div><div class="ttdef"><b>Definition</b> sdns.h:249</div></div>
<div class="ttc" id="asdns_8h_html_abc5aca5cb71471685dd6f7f66aae28e3ab7bff52804c24a581f5518e304207ee0"><div class="ttname"><a href="sdns_8h.html#abc5aca5cb71471685dd6f7f66aae28e3ab7bff52804c24a581f5518e304207ee0">sdns_rr_type_A</a></div><div class="ttdeci">@ sdns_rr_type_A</div><div class="ttdoc">RFC1035 - A record.</div><div class="ttdef"><b>Definition</b> sdns.h:244</div></div>
</div><!-- fragment --><p>As our <em>naivedig</em> only supports A, NS, TXT, MX and SOA, we only hard-coded these values. You can add more resource records (e.g., CNAME, PTR, AAAA, RRSIG, ...) if you want. In case of unknown RR type, <code>convert_type_to_int()</code> function returns -2 and the caller (main function) prints an error code saying that this type is not supported.</p>
<p>Now let's write the <code>main()</code> function which is responsible for making DNS packets and parsing data from sockets.</p>
<div class="fragment"><div class="line"><span class="comment">// main function</span></div>
<div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> ** argv){</div>
<div class="line">    <span class="keywordflow">if</span> (argc != 3){</div>
<div class="line">        fprintf(stdout, <span class="stringliteral">&quot;Usage: ./naivedig &lt;rr-type&gt; &lt;host&gt;\n&quot;</span>);</div>
<div class="line">        <span class="keywordflow">return</span> 1;</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordtype">int</span> type_int = convert_type_to_int(argv[1]);   <span class="comment">// A or TXT or NS or SOA or MX</span></div>
<div class="line">    <span class="keywordflow">if</span> (type_int == -2){</div>
<div class="line">        fprintf(stderr, <span class="stringliteral">&quot;We only support A, TXT, NS, SOA or MX records\n&quot;</span>);</div>
<div class="line">        <span class="keywordflow">return</span> 1;</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordtype">char</span> * domain_name = strdup(argv[2]);</div>
<div class="line">    fprintf(stdout, <span class="stringliteral">&quot;querying %s for %s record...\n&quot;</span>, domain_name, argv[1]);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// let&#39;s create our query packet</span></div>
<div class="line">    <a class="code hl_struct" href="structsdns__context.html">sdns_context</a> * query_ctx = <a class="code hl_function" href="sdns_8h.html#a9a4ce8ee39d593289f8fbacb74eb6456">sdns_init_context</a>();</div>
<div class="line">    <span class="keywordflow">if</span> (NULL == query_ctx){</div>
<div class="line">        fprintf(stderr, <span class="stringliteral">&quot;Can not create the context\n&quot;</span>);</div>
<div class="line">        <span class="keywordflow">return</span> 2;</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordtype">int</span> res = <a class="code hl_function" href="sdns_8h.html#a7d89c4af9c34829f4503a21804cd0917">sdns_make_query</a>(query_ctx, type_int, <a class="code hl_enumvalue" href="sdns_8h.html#a234b54d3d209541e1abe627bd485161da5cbe3170cb87b36e22649a80c55675c4">sdns_q_class_IN</a>, domain_name, 0);</div>
<div class="line">    <span class="keywordflow">if</span> (res != 0){</div>
<div class="line">        fprintf(stderr, <span class="stringliteral">&quot;Can not create the query packet\n&quot;</span>);</div>
<div class="line">        <a class="code hl_function" href="sdns_8h.html#a2d394cf61dcbd6b62aea1e8ecee1e514">sdns_free_context</a>(query_ctx);</div>
<div class="line">        <span class="keywordflow">return</span> 1;</div>
<div class="line">    }</div>
<div class="line">    res = <a class="code hl_function" href="sdns_8h.html#a0bbda400d5feff806b4ae1f9f2031a0b">sdns_to_wire</a>(query_ctx);</div>
<div class="line">    <span class="keywordflow">if</span> (res != 0){</div>
<div class="line">        fprintf(stderr, <span class="stringliteral">&quot;Can not convert the query to binary data\n&quot;</span>);</div>
<div class="line">        <span class="keywordflow">return</span> 1;</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordtype">char</span> * receive_buffer = (<span class="keywordtype">char</span> *) malloc(65535); <span class="comment">// maximum UDP packet</span></div>
<div class="line">    <span class="keywordtype">size_t</span> received_len = 0;</div>
<div class="line">    res = perform_lookup_udp(query_ctx-&gt;<a class="code hl_variable" href="structsdns__context.html#abde5fc772131124fee72eb066298801f">raw</a>, query_ctx-&gt;<a class="code hl_variable" href="structsdns__context.html#a56974606d7845a1e3d89084d1af8c68e">raw_len</a>, &amp;receive_buffer, &amp;received_len);</div>
<div class="line">    <span class="keywordflow">if</span> (res != 0){</div>
<div class="line">        fprintf(stderr, <span class="stringliteral">&quot;Can not perform UDP lookup\n&quot;</span>);</div>
<div class="line">        <a class="code hl_function" href="sdns_8h.html#a2d394cf61dcbd6b62aea1e8ecee1e514">sdns_free_context</a>(query_ctx);</div>
<div class="line">        free(receive_buffer);</div>
<div class="line">        <span class="keywordflow">return</span> 1;</div>
<div class="line">    }</div>
<div class="line">    <span class="comment">// if the received data is not truncated, we have the answer and we can print it</span></div>
<div class="line">    <span class="comment">// otherwise, we have to perform a TCP lookup</span></div>
<div class="line">    <span class="comment">// first we need to parse the received packet.</span></div>
<div class="line">    <a class="code hl_struct" href="structsdns__context.html">sdns_context</a> * received_udp_ctx = <a class="code hl_function" href="sdns_8h.html#a9a4ce8ee39d593289f8fbacb74eb6456">sdns_init_context</a>();</div>
<div class="line">    <span class="keywordflow">if</span> (NULL == received_udp_ctx){</div>
<div class="line">        fprintf(stderr, <span class="stringliteral">&quot;Can not create a new context\n&quot;</span>);</div>
<div class="line">        <a class="code hl_function" href="sdns_8h.html#a2d394cf61dcbd6b62aea1e8ecee1e514">sdns_free_context</a>(query_ctx);</div>
<div class="line">        free(receive_buffer);</div>
<div class="line">        <span class="keywordflow">return</span> 1;</div>
<div class="line">    }</div>
<div class="line">    received_udp_ctx-&gt;<a class="code hl_variable" href="structsdns__context.html#abde5fc772131124fee72eb066298801f">raw</a> = receive_buffer;</div>
<div class="line">    received_udp_ctx-&gt;<a class="code hl_variable" href="structsdns__context.html#a56974606d7845a1e3d89084d1af8c68e">raw_len</a> = received_len;</div>
<div class="line">    res = <a class="code hl_function" href="sdns_8h.html#af49cd2767c9b38bd2f8f15ac0a9ced60">sdns_from_wire</a>(received_udp_ctx);</div>
<div class="line">    <span class="keywordflow">if</span> (res != 0){</div>
<div class="line">        fprintf(stderr, <span class="stringliteral">&quot;Can not parse the received data from UDP socket\n&quot;</span>);</div>
<div class="line">        <a class="code hl_function" href="sdns_8h.html#a2d394cf61dcbd6b62aea1e8ecee1e514">sdns_free_context</a>(received_udp_ctx);</div>
<div class="line">        <a class="code hl_function" href="sdns_8h.html#a2d394cf61dcbd6b62aea1e8ecee1e514">sdns_free_context</a>(query_ctx);</div>
<div class="line">        <span class="keywordflow">return</span> 2;</div>
<div class="line">    }</div>
<div class="line">    <span class="comment">// check if the packet is truncated or not (should we do TCP or not?)</span></div>
<div class="line">    <span class="keywordflow">if</span> (received_udp_ctx-&gt;<a class="code hl_variable" href="structsdns__context.html#a1a33459bdd6cc54d3683d65ae74263c2">msg</a>-&gt;<a class="code hl_variable" href="structsdns__message.html#a9703e67603515f3e4fc46fd720aa668f">header</a>.<a class="code hl_variable" href="structsdns__header.html#a9da4e67cb4189a3d63111cff7df0951b">tc</a> == 1){</div>
<div class="line">        <span class="comment">// we need to perform TCP lookup</span></div>
<div class="line">        fprintf(stdout, <span class="stringliteral">&quot;The packet is truncated...querying using TCP socket....\n&quot;</span>);</div>
<div class="line">        <span class="comment">// we don&#39;t need the answer from UDP and we can free() it</span></div>
<div class="line">        <a class="code hl_function" href="sdns_8h.html#a2d394cf61dcbd6b62aea1e8ecee1e514">sdns_free_context</a>(received_udp_ctx);</div>
<div class="line">        receive_buffer = NULL;</div>
<div class="line">        received_len = 0;</div>
<div class="line">        res = perform_lookup_tcp(query_ctx-&gt;<a class="code hl_variable" href="structsdns__context.html#abde5fc772131124fee72eb066298801f">raw</a>, query_ctx-&gt;<a class="code hl_variable" href="structsdns__context.html#a56974606d7845a1e3d89084d1af8c68e">raw_len</a>, &amp;receive_buffer, &amp;received_len);</div>
<div class="line">        <a class="code hl_function" href="sdns_8h.html#a2d394cf61dcbd6b62aea1e8ecee1e514">sdns_free_context</a>(query_ctx);</div>
<div class="line">        <span class="keywordflow">if</span> (res != 0){</div>
<div class="line">            fprintf(stderr, <span class="stringliteral">&quot;Can not perform TCP lookup\n&quot;</span>);</div>
<div class="line">            <span class="keywordflow">return</span> 1;</div>
<div class="line">        }</div>
<div class="line">        <a class="code hl_struct" href="structsdns__context.html">sdns_context</a> *tcp_ctx = <a class="code hl_function" href="sdns_8h.html#a9a4ce8ee39d593289f8fbacb74eb6456">sdns_init_context</a>();</div>
<div class="line">        tcp_ctx-&gt;<a class="code hl_variable" href="structsdns__context.html#abde5fc772131124fee72eb066298801f">raw</a> = receive_buffer;</div>
<div class="line">        tcp_ctx-&gt;<a class="code hl_variable" href="structsdns__context.html#a56974606d7845a1e3d89084d1af8c68e">raw_len</a> = received_len;</div>
<div class="line">        res = <a class="code hl_function" href="sdns_8h.html#af49cd2767c9b38bd2f8f15ac0a9ced60">sdns_from_wire</a>(tcp_ctx);</div>
<div class="line">        <span class="keywordflow">if</span> (res != 0){</div>
<div class="line">            <a class="code hl_function" href="sdns_8h.html#a2d394cf61dcbd6b62aea1e8ecee1e514">sdns_free_context</a>(tcp_ctx);</div>
<div class="line">            fprintf(stderr, <span class="stringliteral">&quot;Can not parse the DNS packet from TCP wire\n&quot;</span>);</div>
<div class="line">            <span class="keywordflow">return</span> 1;</div>
<div class="line">        }</div>
<div class="line">        <a class="code hl_function" href="sdns__print_8h.html#ad61c15f1479df914af9613b1051ebbed">sdns_neat_print_dns</a>(tcp_ctx);</div>
<div class="line">        <a class="code hl_function" href="sdns_8h.html#a2d394cf61dcbd6b62aea1e8ecee1e514">sdns_free_context</a>(tcp_ctx);</div>
<div class="line">    }<span class="keywordflow">else</span>{</div>
<div class="line">        <span class="comment">// we have the response and we don&#39;t need TCP lookup</span></div>
<div class="line">        <span class="comment">// we don&#39;t need the query context anymore</span></div>
<div class="line">        <a class="code hl_function" href="sdns_8h.html#a2d394cf61dcbd6b62aea1e8ecee1e514">sdns_free_context</a>(query_ctx);</div>
<div class="line">        <span class="comment">// print the received packet nicely</span></div>
<div class="line">        <a class="code hl_function" href="sdns__print_8h.html#ad61c15f1479df914af9613b1051ebbed">sdns_neat_print_dns</a>(received_udp_ctx);</div>
<div class="line">        <span class="comment">// free everything and we are done</span></div>
<div class="line">        <a class="code hl_function" href="sdns_8h.html#a2d394cf61dcbd6b62aea1e8ecee1e514">sdns_free_context</a>(received_udp_ctx);</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
<div class="ttc" id="asdns_8h_html_a0bbda400d5feff806b4ae1f9f2031a0b"><div class="ttname"><a href="sdns_8h.html#a0bbda400d5feff806b4ae1f9f2031a0b">sdns_to_wire</a></div><div class="ttdeci">int sdns_to_wire(sdns_context *ctx)</div><div class="ttdoc">Coverts a DNS context to binary format.</div></div>
<div class="ttc" id="asdns_8h_html_a234b54d3d209541e1abe627bd485161da5cbe3170cb87b36e22649a80c55675c4"><div class="ttname"><a href="sdns_8h.html#a234b54d3d209541e1abe627bd485161da5cbe3170cb87b36e22649a80c55675c4">sdns_q_class_IN</a></div><div class="ttdeci">@ sdns_q_class_IN</div><div class="ttdoc">RFC1035 - the Internet.</div><div class="ttdef"><b>Definition</b> sdns.h:381</div></div>
<div class="ttc" id="asdns_8h_html_a2d394cf61dcbd6b62aea1e8ecee1e514"><div class="ttname"><a href="sdns_8h.html#a2d394cf61dcbd6b62aea1e8ecee1e514">sdns_free_context</a></div><div class="ttdeci">void sdns_free_context(sdns_context *ctx)</div><div class="ttdoc">Frees the context allocated by sdns_init_context().</div></div>
<div class="ttc" id="asdns_8h_html_a7d89c4af9c34829f4503a21804cd0917"><div class="ttname"><a href="sdns_8h.html#a7d89c4af9c34829f4503a21804cd0917">sdns_make_query</a></div><div class="ttdeci">int sdns_make_query(sdns_context *ctx, sdns_rr_type qtype, sdns_q_class cls, char *qname, int enable_edns0)</div><div class="ttdoc">Creates a DNS question query.</div></div>
<div class="ttc" id="asdns_8h_html_a9a4ce8ee39d593289f8fbacb74eb6456"><div class="ttname"><a href="sdns_8h.html#a9a4ce8ee39d593289f8fbacb74eb6456">sdns_init_context</a></div><div class="ttdeci">sdns_context * sdns_init_context(void)</div><div class="ttdoc">Initialize and create a new DNS context.</div></div>
<div class="ttc" id="asdns_8h_html_af49cd2767c9b38bd2f8f15ac0a9ced60"><div class="ttname"><a href="sdns_8h.html#af49cd2767c9b38bd2f8f15ac0a9ced60">sdns_from_wire</a></div><div class="ttdeci">int sdns_from_wire(sdns_context *ctx)</div><div class="ttdoc">Converts the raw data received from socket (bytes) to a DNS packet.</div></div>
<div class="ttc" id="asdns__print_8h_html_ad61c15f1479df914af9613b1051ebbed"><div class="ttname"><a href="sdns__print_8h.html#ad61c15f1479df914af9613b1051ebbed">sdns_neat_print_dns</a></div><div class="ttdeci">void sdns_neat_print_dns(sdns_context *ctx)</div><div class="ttdoc">Prints a DNS packet in a human-readable format (like Dig)</div></div>
<div class="ttc" id="astructsdns__context_html"><div class="ttname"><a href="structsdns__context.html">sdns_context</a></div><div class="ttdef"><b>Definition</b> sdns.h:661</div></div>
<div class="ttc" id="astructsdns__context_html_a1a33459bdd6cc54d3683d65ae74263c2"><div class="ttname"><a href="structsdns__context.html#a1a33459bdd6cc54d3683d65ae74263c2">sdns_context::msg</a></div><div class="ttdeci">sdns_message * msg</div><div class="ttdoc">This is the DNS packet.</div><div class="ttdef"><b>Definition</b> sdns.h:662</div></div>
<div class="ttc" id="astructsdns__context_html_a56974606d7845a1e3d89084d1af8c68e"><div class="ttname"><a href="structsdns__context.html#a56974606d7845a1e3d89084d1af8c68e">sdns_context::raw_len</a></div><div class="ttdeci">uint16_t raw_len</div><div class="ttdoc">Length of the raw data we received from socket.</div><div class="ttdef"><b>Definition</b> sdns.h:664</div></div>
<div class="ttc" id="astructsdns__context_html_abde5fc772131124fee72eb066298801f"><div class="ttname"><a href="structsdns__context.html#abde5fc772131124fee72eb066298801f">sdns_context::raw</a></div><div class="ttdeci">char * raw</div><div class="ttdoc">The raw bytes we received from socket.</div><div class="ttdef"><b>Definition</b> sdns.h:663</div></div>
<div class="ttc" id="astructsdns__header_html_a9da4e67cb4189a3d63111cff7df0951b"><div class="ttname"><a href="structsdns__header.html#a9da4e67cb4189a3d63111cff7df0951b">sdns_header::tc</a></div><div class="ttdeci">uint8_t tc</div><div class="ttdoc">RFC1035: 1-bit TrunCation.</div><div class="ttdef"><b>Definition</b> sdns.h:420</div></div>
<div class="ttc" id="astructsdns__message_html_a9703e67603515f3e4fc46fd720aa668f"><div class="ttname"><a href="structsdns__message.html#a9703e67603515f3e4fc46fd720aa668f">sdns_message::header</a></div><div class="ttdeci">sdns_header header</div><div class="ttdoc">See sdns_header for more info.</div><div class="ttdef"><b>Definition</b> sdns.h:472</div></div>
</div><!-- fragment --><p>Most parts of the <code>main()</code> function are error checking but we are going to break it down and explain each part.</p>
<div class="fragment"><div class="line"><span class="keywordflow">if</span> (argc != 3){</div>
<div class="line">    fprintf(stdout, <span class="stringliteral">&quot;Usage: ./naivedig &lt;rr-type&gt; &lt;host&gt;\n&quot;</span>);</div>
<div class="line">    <span class="keywordflow">return</span> 1;</div>
<div class="line">}</div>
<div class="line"><span class="keywordtype">int</span> type_int = convert_type_to_int(argv[1]);   <span class="comment">// A or TXT or NS or SOA or MX</span></div>
<div class="line"><span class="keywordflow">if</span> (type_int == -2){</div>
<div class="line">    fprintf(stderr, <span class="stringliteral">&quot;We only support A, TXT, NS, SOA or MX records\n&quot;</span>);</div>
<div class="line">    <span class="keywordflow">return</span> 1;</div>
<div class="line">}</div>
<div class="line"><span class="keywordtype">char</span> * domain_name = strdup(argv[2]);</div>
<div class="line">fprintf(stdout, <span class="stringliteral">&quot;querying %s for %s record...\n&quot;</span>, domain_name, argv[1]);</div>
</div><!-- fragment --><p>At first, we check the number of input from the user and if it's not 3, we show the usage and exit. We also convert the input RR type using <code>convert_type_to_int()</code> function and if the user input is not one of the A, NS, TXT, SOA or, MX values, we show an error and exit. We also copy the hostname using <code>strdup()</code> function. This is important because later in the code, we will pass this value to <a class="el" href="sdns_8h.html#a7d89c4af9c34829f4503a21804cd0917" title="Creates a DNS question query.">sdns_make_query()</a> function and it will be part of our DNS packet structure. When we call <a class="el" href="sdns_8h.html#a2d394cf61dcbd6b62aea1e8ecee1e514" title="Frees the context allocated by sdns_init_context().">sdns_free_context()</a> function, it tries to use <code>free()</code> on <b>qname</b> field of the <a class="el" href="structsdns__question.html">sdns_question</a> structure. So, we need to make sure it's a heap-allocated memory so that we can free it without errors.</p>
<div class="fragment"><div class="line"><span class="comment">// let&#39;s create our query packet</span></div>
<div class="line"><a class="code hl_struct" href="structsdns__context.html">sdns_context</a> * query_ctx = <a class="code hl_function" href="sdns_8h.html#a9a4ce8ee39d593289f8fbacb74eb6456">sdns_init_context</a>();</div>
<div class="line"><span class="keywordflow">if</span> (NULL == query_ctx){</div>
<div class="line">    fprintf(stderr, <span class="stringliteral">&quot;Can not create the context\n&quot;</span>);</div>
<div class="line">    <span class="keywordflow">return</span> 2;</div>
<div class="line">}</div>
<div class="line"><span class="keywordtype">int</span> res = <a class="code hl_function" href="sdns_8h.html#a7d89c4af9c34829f4503a21804cd0917">sdns_make_query</a>(query_ctx, type_int, <a class="code hl_enumvalue" href="sdns_8h.html#a234b54d3d209541e1abe627bd485161da5cbe3170cb87b36e22649a80c55675c4">sdns_q_class_IN</a>, domain_name, 0);</div>
<div class="line"><span class="keywordflow">if</span> (res != 0){</div>
<div class="line">    fprintf(stderr, <span class="stringliteral">&quot;Can not create the query packet\n&quot;</span>);</div>
<div class="line">    <a class="code hl_function" href="sdns_8h.html#a2d394cf61dcbd6b62aea1e8ecee1e514">sdns_free_context</a>(query_ctx);</div>
<div class="line">    <span class="keywordflow">return</span> 1;</div>
<div class="line">}</div>
<div class="line">res = <a class="code hl_function" href="sdns_8h.html#a0bbda400d5feff806b4ae1f9f2031a0b">sdns_to_wire</a>(query_ctx);</div>
<div class="line"><span class="keywordflow">if</span> (res != 0){</div>
<div class="line">    fprintf(stderr, <span class="stringliteral">&quot;Can not convert the query to binary data\n&quot;</span>);</div>
<div class="line">    <span class="keywordflow">return</span> 1;</div>
<div class="line">}</div>
</div><!-- fragment --><p>The second part of the <code>main()</code> function is about making the query packet from users input data. First we create a DNS context (query_ctx) using <a class="el" href="sdns_8h.html#a9a4ce8ee39d593289f8fbacb74eb6456" title="Initialize and create a new DNS context.">sdns_init_context()</a> function. Then we make the question section of our DNS packet by calling <a class="el" href="sdns_8h.html#a7d89c4af9c34829f4503a21804cd0917" title="Creates a DNS question query.">sdns_make_query()</a> function and user's input data. The last parameter of <a class="el" href="sdns_8h.html#a7d89c4af9c34829f4503a21804cd0917" title="Creates a DNS question query.">sdns_make_query()</a> is 0 which tells the function not to add EDNS0 option. This means that our packet is not EDNS0 aware. If you want to add EDNS0 support, all you have to do is to pass 1 instead of 0.</p>
<p>Finally, we try to convert the created context to wire format by calling <a class="el" href="sdns_8h.html#a0bbda400d5feff806b4ae1f9f2031a0b" title="Coverts a DNS context to binary format.">sdns_to_wire()</a> function. <a class="el" href="sdns_8h.html#a0bbda400d5feff806b4ae1f9f2031a0b" title="Coverts a DNS context to binary format.">sdns_to_wire()</a> function basically reads the <b>msg</b> field of the context and fill the <b>raw</b> and <b>raw_len</b> field appropriately. If the operation is successful, it returns zero.</p>
<p>For all the 3 functions we called (<a class="el" href="sdns_8h.html#a9a4ce8ee39d593289f8fbacb74eb6456" title="Initialize and create a new DNS context.">sdns_init_context()</a>, <a class="el" href="sdns_8h.html#a7d89c4af9c34829f4503a21804cd0917" title="Creates a DNS question query.">sdns_make_query()</a>, and <a class="el" href="sdns_8h.html#a0bbda400d5feff806b4ae1f9f2031a0b" title="Coverts a DNS context to binary format.">sdns_to_wire()</a>), we must check the return value. All of them return 0 on success. If they return any other value than 0, then we can get the description of the error by calling <a class="el" href="sdns_8h.html#af1904f3b99e921966cad992011ed68b6" title="Coverts error codes to a string.">sdns_error_string()</a> function and passing the return value to it.</p>
<div class="fragment"><div class="line"><span class="keywordtype">char</span> * receive_buffer = (<span class="keywordtype">char</span> *) malloc(65535); <span class="comment">// maximum UDP packet</span></div>
<div class="line"><span class="keywordtype">size_t</span> received_len = 0;</div>
<div class="line">res = perform_lookup_udp(query_ctx-&gt;<a class="code hl_variable" href="structsdns__context.html#abde5fc772131124fee72eb066298801f">raw</a>, query_ctx-&gt;<a class="code hl_variable" href="structsdns__context.html#a56974606d7845a1e3d89084d1af8c68e">raw_len</a>, &amp;receive_buffer, &amp;received_len);</div>
<div class="line"><span class="keywordflow">if</span> (res != 0){</div>
<div class="line">    fprintf(stderr, <span class="stringliteral">&quot;Can not perform UDP lookup\n&quot;</span>);</div>
<div class="line">    <a class="code hl_function" href="sdns_8h.html#a2d394cf61dcbd6b62aea1e8ecee1e514">sdns_free_context</a>(query_ctx);</div>
<div class="line">    free(receive_buffer);</div>
<div class="line">    <span class="keywordflow">return</span> 1;</div>
<div class="line">}</div>
</div><!-- fragment --><p>We don't know the length of the packet we receive from the destination (here the destination is 1.1.1.1:53), However, we know that the maximum size of a UDP packet is 65535 bytes. So we allocate a buffer of this size for receiving the result and we pass it to <code>perform_lookup_udp()</code> function. In case of success (sending and receiving data successfully), the function return 0.</p>
<p>What we send to the socket is the data in the <b>raw</b> field of the DNS context which was field by calling <a class="el" href="sdns_8h.html#a0bbda400d5feff806b4ae1f9f2031a0b" title="Coverts a DNS context to binary format.">sdns_to_wire()</a> function.</p>
<div class="fragment"><div class="line"><span class="comment">// if the received data is not truncated, we have the answer and we can print it</span></div>
<div class="line"><span class="comment">// otherwise, we have to perform a TCP lookup</span></div>
<div class="line"><span class="comment">// first we need to parse the received packet.</span></div>
<div class="line"><a class="code hl_struct" href="structsdns__context.html">sdns_context</a> * received_udp_ctx = <a class="code hl_function" href="sdns_8h.html#a9a4ce8ee39d593289f8fbacb74eb6456">sdns_init_context</a>();</div>
<div class="line"><span class="keywordflow">if</span> (NULL == received_udp_ctx){</div>
<div class="line">    fprintf(stderr, <span class="stringliteral">&quot;Can not create a new context\n&quot;</span>);</div>
<div class="line">    <a class="code hl_function" href="sdns_8h.html#a2d394cf61dcbd6b62aea1e8ecee1e514">sdns_free_context</a>(query_ctx);</div>
<div class="line">    free(receive_buffer);</div>
<div class="line">    <span class="keywordflow">return</span> 1;</div>
<div class="line">}</div>
<div class="line">received_udp_ctx-&gt;<a class="code hl_variable" href="structsdns__context.html#abde5fc772131124fee72eb066298801f">raw</a> = receive_buffer;</div>
<div class="line">received_udp_ctx-&gt;<a class="code hl_variable" href="structsdns__context.html#a56974606d7845a1e3d89084d1af8c68e">raw_len</a> = received_len;</div>
<div class="line">res = <a class="code hl_function" href="sdns_8h.html#af49cd2767c9b38bd2f8f15ac0a9ced60">sdns_from_wire</a>(received_udp_ctx);</div>
<div class="line"><span class="keywordflow">if</span> (res != 0){</div>
<div class="line">    fprintf(stderr, <span class="stringliteral">&quot;Can not parse the received data from UDP socket\n&quot;</span>);</div>
<div class="line">    <a class="code hl_function" href="sdns_8h.html#a2d394cf61dcbd6b62aea1e8ecee1e514">sdns_free_context</a>(received_udp_ctx);</div>
<div class="line">    <a class="code hl_function" href="sdns_8h.html#a2d394cf61dcbd6b62aea1e8ecee1e514">sdns_free_context</a>(query_ctx);</div>
<div class="line">    <span class="keywordflow">return</span> 2;</div>
<div class="line">}</div>
</div><!-- fragment --><p>After successfully receiving data from the UDP socket, we need to convert the raw data we received, to a DNS packet. This is done by creating a new context (using <a class="el" href="sdns_8h.html#a9a4ce8ee39d593289f8fbacb74eb6456" title="Initialize and create a new DNS context.">sdns_init_context()</a>) and setting its <b>raw</b> and <b>raw_len</b> fields, then, pass the newly created context to <a class="el" href="sdns_8h.html#af49cd2767c9b38bd2f8f15ac0a9ced60" title="Converts the raw data received from socket (bytes) to a DNS packet.">sdns_from_wire()</a> function to parse the binary data to a meaningful DNS packet.</p>
<p>Note that <a class="el" href="sdns_8h.html#af49cd2767c9b38bd2f8f15ac0a9ced60" title="Converts the raw data received from socket (bytes) to a DNS packet.">sdns_from_wire()</a> is exactly the opposite of <a class="el" href="sdns_8h.html#a0bbda400d5feff806b4ae1f9f2031a0b" title="Coverts a DNS context to binary format.">sdns_to_wire()</a> function.</p>
<p>In case of error, we have to clean up the memory and quit. Otherwise we can continue to:</p>
<div class="fragment"><div class="line"><span class="comment">// check if the packet is truncated or not (should we do TCP or not?)</span></div>
<div class="line"><span class="keywordflow">if</span> (received_udp_ctx-&gt;<a class="code hl_variable" href="structsdns__context.html#a1a33459bdd6cc54d3683d65ae74263c2">msg</a>-&gt;<a class="code hl_variable" href="structsdns__message.html#a9703e67603515f3e4fc46fd720aa668f">header</a>.<a class="code hl_variable" href="structsdns__header.html#a9da4e67cb4189a3d63111cff7df0951b">tc</a> == 1){</div>
<div class="line">    <span class="comment">// we need to perform TCP lookup</span></div>
<div class="line">    fprintf(stdout, <span class="stringliteral">&quot;The packet is truncated...querying using TCP socket....\n&quot;</span>);</div>
<div class="line">    <span class="comment">// we don&#39;t need the answer from UDP and we can free() it</span></div>
<div class="line">    <a class="code hl_function" href="sdns_8h.html#a2d394cf61dcbd6b62aea1e8ecee1e514">sdns_free_context</a>(received_udp_ctx);</div>
<div class="line">    receive_buffer = NULL;</div>
<div class="line">    received_len = 0;</div>
<div class="line">    res = perform_lookup_tcp(query_ctx-&gt;<a class="code hl_variable" href="structsdns__context.html#abde5fc772131124fee72eb066298801f">raw</a>, query_ctx-&gt;<a class="code hl_variable" href="structsdns__context.html#a56974606d7845a1e3d89084d1af8c68e">raw_len</a>, &amp;receive_buffer, &amp;received_len);</div>
<div class="line">    <a class="code hl_function" href="sdns_8h.html#a2d394cf61dcbd6b62aea1e8ecee1e514">sdns_free_context</a>(query_ctx);</div>
<div class="line">    <span class="keywordflow">if</span> (res != 0){</div>
<div class="line">        fprintf(stderr, <span class="stringliteral">&quot;Can not perform TCP lookup\n&quot;</span>);</div>
<div class="line">        <span class="keywordflow">return</span> 1;</div>
<div class="line">    }</div>
<div class="line">    <a class="code hl_struct" href="structsdns__context.html">sdns_context</a> *tcp_ctx = <a class="code hl_function" href="sdns_8h.html#a9a4ce8ee39d593289f8fbacb74eb6456">sdns_init_context</a>();</div>
<div class="line">    tcp_ctx-&gt;<a class="code hl_variable" href="structsdns__context.html#abde5fc772131124fee72eb066298801f">raw</a> = receive_buffer;</div>
<div class="line">    tcp_ctx-&gt;<a class="code hl_variable" href="structsdns__context.html#a56974606d7845a1e3d89084d1af8c68e">raw_len</a> = received_len;</div>
<div class="line">    res = <a class="code hl_function" href="sdns_8h.html#af49cd2767c9b38bd2f8f15ac0a9ced60">sdns_from_wire</a>(tcp_ctx);</div>
<div class="line">    <span class="keywordflow">if</span> (res != 0){</div>
<div class="line">        <a class="code hl_function" href="sdns_8h.html#a2d394cf61dcbd6b62aea1e8ecee1e514">sdns_free_context</a>(tcp_ctx);</div>
<div class="line">        fprintf(stderr, <span class="stringliteral">&quot;Can not parse the DNS packet from TCP wire\n&quot;</span>);</div>
<div class="line">        <span class="keywordflow">return</span> 1;</div>
<div class="line">    }</div>
<div class="line">    <a class="code hl_function" href="sdns__print_8h.html#ad61c15f1479df914af9613b1051ebbed">sdns_neat_print_dns</a>(tcp_ctx);</div>
<div class="line">    <a class="code hl_function" href="sdns_8h.html#a2d394cf61dcbd6b62aea1e8ecee1e514">sdns_free_context</a>(tcp_ctx);</div>
<div class="line">}<span class="keywordflow">else</span>{</div>
<div class="line">    <span class="comment">// we have the response and we don&#39;t need TCP lookup</span></div>
<div class="line">    <span class="comment">// we don&#39;t need the query context anymore</span></div>
<div class="line">    <a class="code hl_function" href="sdns_8h.html#a2d394cf61dcbd6b62aea1e8ecee1e514">sdns_free_context</a>(query_ctx);</div>
<div class="line">    <span class="comment">// print the received packet nicely</span></div>
<div class="line">    <a class="code hl_function" href="sdns__print_8h.html#ad61c15f1479df914af9613b1051ebbed">sdns_neat_print_dns</a>(received_udp_ctx);</div>
<div class="line">    <span class="comment">// free everything and we are done</span></div>
<div class="line">    <a class="code hl_function" href="sdns_8h.html#a2d394cf61dcbd6b62aea1e8ecee1e514">sdns_free_context</a>(received_udp_ctx);</div>
<div class="line">}</div>
</div><!-- fragment --><p>So this part of the code is doing the main job for us. It has a big if..else which breaks the code into two parts for us:</p>
<ol type="1">
<li>if the data is truncated (<code>received_udp_ctx-&gt;msg-&gt;header.tc == 1</code>)</li>
<li>if the data is not truncated (tc != 1)</li>
</ol>
<p>Let's explain the second part which is more common (i.e., <code>tc != 1</code>).</p>
<p><b>TC</b> is the truncation bit in the DNS header (RFC1035). When its value is 1, it means that the response is bigger than a single UDP transaction. Therefore, the requester must switch to TCP and send the request again.</p>
<p>When TC is zero, it means we have received the full answer from the remote server and we don't need another request (the <em>else</em> part of the code). In this case, we can just print the DNS packet (or do whatever we want). You can print the DNS packet in any format you want. However, I also provided a few functions (<b>sdns_neat_print_*()</b> functions) to simplify the job. So we have the final answer from the server and we have already parsed the answer packet by calling <a class="el" href="sdns_8h.html#af49cd2767c9b38bd2f8f15ac0a9ced60" title="Converts the raw data received from socket (bytes) to a DNS packet.">sdns_from_wire()</a> function. Now we can easily call <a class="el" href="sdns__print_8h.html#ad61c15f1479df914af9613b1051ebbed" title="Prints a DNS packet in a human-readable format (like Dig)">sdns_neat_print_dns()</a> function to see the output!</p>
<p>finally we need to clean the memory and we are done!</p>
<p>Now consider if TC=1. That means the package is truncated, the received answer from UDP is not the real, valid answer and we need to make another query but this time on TCP!</p>
<p>So we don't need the received answer from UDP anymore. We can free its memory by calling <code>sdns_free_context(received_udp_ctx)</code> and then we perform a new TCP lookup by calling <code>perform_lookup_tcp</code> function. This is the final result no matter what it is and we can print it out by calling <a class="el" href="sdns__print_8h.html#ad61c15f1479df914af9613b1051ebbed" title="Prints a DNS packet in a human-readable format (like Dig)">sdns_neat_print_dns()</a> function.</p>
<p>That's it! We have our <em>naivedig</em> in ~250 lines of code.</p>
<p>You can compile the code manually by:</p>
<div class="fragment"><div class="line"># compile our naivedig</div>
<div class="line">gcc -I. sdns.c naivedig.c dns_utils.c dynamic_buffer.c neat_print.c -o naivedig</div>
</div><!-- fragment --><p> And let's see the output of executing <code>./naivedig NS microsoft.com</code></p>
<div class="fragment"><div class="line">querying microsoft.com for NS record...</div>
<div class="line">** DNS MESSAGE HEADER</div>
<div class="line">    ID: 45298,  qr: 1,  opcode: 0,  aa: 0,  tc: 0,  rd: 1,  ra: 1</div>
<div class="line">    z: 0,  AD: 0,  CD: 0,  rcode: NoError  qdcount: 1,  ancount: 4,  arcount: 0,  nscount: 0</div>
<div class="line">** DNS QUESTION SECTION</div>
<div class="line">    microsoft.com.  IN  NS</div>
<div class="line">** DNS ANSWER SECTION</div>
<div class="line">    microsoft.com.  164773  IN  NS  ns1-39.azure-dns.com.</div>
<div class="line">    microsoft.com.  164773  IN  NS  ns2-39.azure-dns.net.</div>
<div class="line">    microsoft.com.  164773  IN  NS  ns3-39.azure-dns.org.</div>
<div class="line">    microsoft.com.  164773  IN  NS  ns4-39.azure-dns.info.</div>
<div class="line">** DNS AUTHORITY SECTION</div>
<div class="line">** DNS ADDITIONAL SECTION</div>
</div><!-- fragment --><p>And the output of <code>./naivedig TXT microsoft.com</code></p>
<div class="fragment"><div class="line">querying microsoft.com for TXT record...</div>
<div class="line">The packet is truncated...querying using TCP socket....</div>
<div class="line">** DNS MESSAGE HEADER</div>
<div class="line">    ID: 45298,  qr: 1,  opcode: 0,  aa: 0,  tc: 0,  rd: 1,  ra: 1</div>
<div class="line">    z: 0,  AD: 0,  CD: 0,  rcode: NoError  qdcount: 1,  ancount: 20,  arcount: 0,  nscount: 0</div>
<div class="line">** DNS QUESTION SECTION</div>
<div class="line">    microsoft.com.  IN  TXT</div>
<div class="line">** DNS ANSWER SECTION</div>
<div class="line">    microsoft.com.  1786    IN  TXT     &quot;d365mktkey=3uc1cf82cpv750lzk70v9bvf2&quot; </div>
<div class="line">    microsoft.com.  1786    IN  TXT     &quot;facebook-domain-verification=fwzwhbbzwmg5fzgotc2go51olc3566&quot; </div>
<div class="line">    microsoft.com.  1786    IN  TXT     &quot;google-site-verification=pjPOauSPcrfXOZS9jnPPa5axowcHGCDAl1_86dCqFpk&quot; </div>
<div class="line">    microsoft.com.  1786    IN  TXT     &quot;fg2t0gov9424p2tdcuo94goe9j&quot; </div>
<div class="line">    microsoft.com.  1786    IN  TXT     &quot;t7sebee51jrj7vm932k531hipa&quot; </div>
<div class="line">    microsoft.com.  1786    IN  TXT     &quot;google-site-verification=M--CVfn_YwsV-2FGbCp_HFaEj23BmT0cTF4l8hXgpvM&quot; </div>
<div class="line">    microsoft.com.  1786    IN  TXT     &quot;google-site-verification=GfDnTUdATPsK1230J0mXbfsYw-3A9BVMVaKSd4DcKgI&quot; </div>
<div class="line">    microsoft.com.  1786    IN  TXT     &quot;d365mktkey=SxDf1EZxLvMwx6eEZUxzjFFgHoapF8DvtWEUjwq7ZTwx&quot; </div>
<div class="line">    microsoft.com.  1786    IN  TXT     &quot;hubspot-developer-verification=OTQ5NGIwYWEtODNmZi00YWE1LTkyNmQtNDhjMDMxY2JjNDAx&quot; </div>
<div class="line">    microsoft.com.  1786    IN  TXT     &quot;d365mktkey=QDa792dLCZhvaAOOCe2Hz6WTzmTssOp1snABhxWibhMx&quot; </div>
<div class="line">    microsoft.com.  1786    IN  TXT     &quot;d365mktkey=6358r1b7e13hox60tl1uagv14&quot; </div>
<div class="line">    microsoft.com.  1786    IN  TXT     &quot;google-site-verification=uFg3wr5PWsK8lV029RoXXBBUW0_E6qf1WEWVHhetkOY&quot; </div>
<div class="line">    microsoft.com.  1786    IN  TXT     &quot;docusign=d5a3737c-c23c-4bd0-9095-d2ff621f2840&quot; </div>
<div class="line">    microsoft.com.  1786    IN  TXT     &quot;d365mktkey=j2qHWq9BHdaa3ZXZH8x64daJZxEWsFa0dxDeilxDoYYx&quot; </div>
<div class="line">    microsoft.com.  1786    IN  TXT     &quot;v=spf1 include:_spf-a.microsoft.com include:_spf-b.microsoft.com include:_spf-c.microsoft.com include:_spf-ssg-a.msft.net include:spf-a.hotmail.com include:_spf1-meo.microsoft.com -all&quot; </div>
<div class="line">    microsoft.com.  1786    IN  TXT     &quot;atlassian-domain-verification=xvoaqRfxSg3PnlVnR4xCSOlKyw1Aln0MMxRiKXnwWroFG7vI76TUC8xYb03MwMXv&quot; </div>
<div class="line">    microsoft.com.  1786    IN  TXT     &quot;workplace-domain-verification=lK0QDLk73xymCYMKUXNpfKAT8TY5Mx&quot; </div>
<div class="line">    microsoft.com.  1786    IN  TXT     &quot;google-site-verification=uhh5_jbxpcQgnb-A7gDIjlrr5Ef34lA2t2_BAveYpnk&quot; </div>
<div class="line">    microsoft.com.  1786    IN  TXT     &quot;MS=ms79629062&quot; </div>
<div class="line">    microsoft.com.  1786    IN  TXT     &quot;ms-domain-verification=9feeb5bd-0f21-44bd-aa3d-ad0b1085c629&quot; </div>
<div class="line">** DNS AUTHORITY SECTION</div>
<div class="line">** DNS ADDITIONAL SECTION</div>
</div><!-- fragment --><p>In the next tutorial, we will build more interesting tools. </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8
</small></address>
</body>
</html>
